ERC20定义了三个可选函数：

function name() view returns (string name);

// 代币符号。按惯例一般用全大写字母，比如“SLPT”。
function symbol() view returns (string symbol);

// 小数位数。不少代币采用与ETH一样的设定，也就是18位。
// 这只影响用户界面中货币量的显示方式。代币本身都统一用uint256表示。
function decimal() view returns (uint8 decimals);



这三个函数都是返回常量，在Solidity中也可以用以下简略形式定义。solc编译器会自动生成与以上接口等价的字节码。

string public name = "Sleepism Token";

string public symbol = "SLPT";

uint8 public decimal = 18;

ERC20定义了六个必须声明的函数：

// 代币总量。
function totalSupply() view returns (uint256 totalSupply);



// 查询指定地址下的代币余额。
function balanceOf(address _owner) view returns (uint256 balance);



// 给指定地址转入指定量的代币，转账成功则返回true。
// 如果源地址没有足够量的代币，函数应该抛出异常。
// 即使转零个代币，也应该触发Transfer事件。
function transfer(address _to, uint256 _value) returns (bool success);



// 与transfer类似的转账函数。区别在于可以指定一个转出地址。
// 如果当前地址得到了转出地址的授权，则可以代理转账操作。
function transferFrom(address _from, address _to, uint256 _value) returns (bool success);



// 授权指定地址特定的转账额度。
// 被授权的地址可以多次调用transferFrom函数代替源地址转账，总值不超过_value。
// 实际使用时，每次重设额度前应该先调用approve(_spender, 0)，
// 等交易被确认后再调用approve(_spender, newAllowance)。
// 如果直接调用一次approve，被授权地址有机会转出高出指定额度的代币。
function approve(address _spender, uint256 _value) returns (bool success);




// 查询指定授权地址剩余的转账额度。
function allowance(address _owner, address _spender) view returns (uint256 remaining);




ERC20还定义了两个事件：

// 转账事件。必须在成功转账（哪怕是零个代币）时触发。
event Transfer(address indexed _from, address indexed _to, uint256 _value);



// 授权事件。必须在成功授权时触发。
event Approval(address indexed _owner, address indexed _spender, uint256 _value);






=====================================

ERC721

ERC721与ERC20有些相似，但由于它管理的是非互换性资产（non-fungible token，简称NFT），所以函数语义并不一样。
合约下每份ERC721资产都拥有一个uint256类型的独立编号（_tokenId）。


ERC721事件：

// 转账事件。从_from地址转移_tokenId对应资产的所有权到_to地址时触发。
event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);



// 授权转账事件。把_owner地址控制的_tokenId资产授权给_approved地址时触发。
// 发生转账事件时，对应资产的授权地址应被清空。
event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);





// 授权管理事件。_owner地址授权或取消授权_operator地址的管理权时触发。
event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);



ERC721函数：

// 查询_owner地址拥有的NFT总个数。
function balanceOf(address _owner) external view returns (uint256);


// 查询_tokenId资产的所属地址。
function ownerOf(uint256 _tokenId) external view returns (address);



// 将_from地址所拥有的_tokenId资产转移给_to地址。
// 调用方必须是资产主人或是已被授权的地址，否则会抛出异常。方法成功后需触发Transfer事件
function transferFrom(address _from, address _to, uint256 _tokenId) external payable;

调用者msg.sender应该是当前tokenId的所有者或被授权的地址
_from 必须是 _tokenId的所有者
_tokenId 应该是当前合约正在监测的NFTs 中的任何一个
_to 地址不应该为 0



// 与transferFrom类似的资产转移函数。
// 它会额外检查_to地址和_tokenId的有效性，另外如果_to是合约地址，
// 还会触发它的onERC721Received回调函数。
function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;

调用者msg.sender应该是当前tokenId的所有者或被授权的地址
_from 必须是 _tokenId的所有者
_tokenId 应该是当前合约正在监测的NFTs 中的任何一个
_to 地址不应该为 0
如果_to 是一个合约应该调用其onERC721Received方法, 并且检查其返回值，如果返回值不为bytes4(keccak256("onERC721Received(address,uint256,bytes)"))抛出异常。
一个可接收NFT的合约必须实现ERC721TokenReceiver接口：
interface ERC721TokenReceiver {
    /// @return `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`
    function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);
}






// 与上述接口类似的资产转移函数。
// 唯一不同点是可以传入额外的自定义参数。
function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;




// 把_tokenId资产授权给_approved地址。方法成功后需触发Approval 事件。
function approve(address _approved, uint256 _tokenId) external payable;




// 查询_tokenId资产对应的授权地址。
function getApproved(uint256 _tokenId) external view returns (address);



// 指定或撤销_operator地址的管理权限。成功后需触发ApprovalForAll事件。
function setApprovalForAll(address _operator, bool _approved) external;




// 查询_operator地址是否已经获得_owner地址的管理权。
function isApprovedForAll(address _owner, address _operator) external view returns (bool);




ERC721元数据接口（可选项）：
interface ERC721Metadata

// 资产名称。比如"Sleepism Collectible"。
function name() external pure returns (string _name);


// 资产符号。比如"SLPC"。
function symbol() external pure returns (string _symbol);


// 描述_tokenId资产的URI。指向一个符合ERC721元数据描述结构的JSON文件。
function tokenURI(uint256 _tokenId) external view returns (string);



元数据描述结构如下所示：

{

"title": "Sleepism Collectible Metadata",

"type": "object",

"properties": {

"name": {

"type": "string",

"description": "Sleep and his Half-brother Death",

},

"description": {

"type": "string",

"description": "A painting by John William Waterhouse",

},

"image": {

"type": "string",

"description": "https://i.imgur.com/sahhbd.png",

}

}

}




ERC721枚举扩宽接口（可选项）：
interface ERC721Enumerable

// 合约管理的总NFT数量。
function totalSupply() external view returns (uint256);


// 查询第_index个资产的编码。
function tokenByIndex(uint256 _index) external view returns (uint256);


// 查询_owner地址拥有的第_index个资产的编码。
function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);



符合ERC721协议的合约还需要符合ERC165规范，实现以下函数：

// 查询合约是否实现了interfaceID对应的接口。
interface ERC165 {
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}


interfaceID由bytes4(keccak256(函数签名))计算得到。有多个函数时，将全部byte4异或（xor）得到最终结果。
详见ERC165标准文档（https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md）。

例如以下接受转账回调函数接口的interfaceID就是0xf0b9e5ba：

interface ERC721TokenReceiver {

function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);

}
















pragma solidity ^0.4.20;

/// @title ERC-721 Non-Fungible Token Standard
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md
///  Note: the ERC-165 identifier for this interface is 0x80ac58cd
interface ERC721 /* is ERC165 */ {
    /// @dev This emits when ownership of any NFT changes by any mechanism.
    ///  This event emits when NFTs are created (`from` == 0) and destroyed
    ///  (`to` == 0). Exception: during contract creation, any number of NFTs
    ///  may be created and assigned without emitting Transfer. At the time of
    ///  any transfer, the approved address for that NFT (if any) is reset to none.
    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);

    /// @dev This emits when the approved address for an NFT is changed or
    ///  reaffirmed. The zero address indicates there is no approved address.
    ///  When a Transfer event emits, this also indicates that the approved
    ///  address for that NFT (if any) is reset to none.
    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);

    /// @dev This emits when an operator is enabled or disabled for an owner.
    ///  The operator can manage all NFTs of the owner.
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    /// @notice Count all NFTs assigned to an owner
    /// @dev NFTs assigned to the zero address are considered invalid, and this
    ///  function throws for queries about the zero address.
    /// @param _owner An address for whom to query the balance
    /// @return The number of NFTs owned by `_owner`, possibly zero
    function balanceOf(address _owner) external view returns (uint256);

    /// @notice Find the owner of an NFT
    /// @dev NFTs assigned to zero address are considered invalid, and queries
    ///  about them do throw.
    /// @param _tokenId The identifier for an NFT
    /// @return The address of the owner of the NFT
    function ownerOf(uint256 _tokenId) external view returns (address);

    /// @notice Transfers the ownership of an NFT from one address to another address
    /// @dev Throws unless `msg.sender` is the current owner, an authorized
    ///  operator, or the approved address for this NFT. Throws if `_from` is
    ///  not the current owner. Throws if `_to` is the zero address. Throws if
    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function
    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls
    ///  `onERC721Received` on `_to` and throws if the return value is not
    ///  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    /// @param data Additional data with no specified format, sent in call to `_to`
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;

    /// @notice Transfers the ownership of an NFT from one address to another address
    /// @dev This works identically to the other function with an extra data parameter,
    ///  except this function just sets data to ""
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;

    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
    ///  THEY MAY BE PERMANENTLY LOST
    /// @dev Throws unless `msg.sender` is the current owner, an authorized
    ///  operator, or the approved address for this NFT. Throws if `_from` is
    ///  not the current owner. Throws if `_to` is the zero address. Throws if
    ///  `_tokenId` is not a valid NFT.
    /// @param _from The current owner of the NFT
    /// @param _to The new owner
    /// @param _tokenId The NFT to transfer
    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;

    /// @notice Set or reaffirm the approved address for an NFT
    /// @dev The zero address indicates there is no approved address.
    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized
    ///  operator of the current owner.
    /// @param _approved The new approved NFT controller
    /// @param _tokenId The NFT to approve
    function approve(address _approved, uint256 _tokenId) external payable;

    /// @notice Enable or disable approval for a third party ("operator") to manage
    ///  all of `msg.sender`'s assets.
    /// @dev Emits the ApprovalForAll event. The contract MUST allow
    ///  multiple operators per owner.
    /// @param _operator Address to add to the set of authorized operators.
    /// @param _approved True if the operator is approved, false to revoke approval
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice Get the approved address for a single NFT
    /// @dev Throws if `_tokenId` is not a valid NFT
    /// @param _tokenId The NFT to find the approved address for
    /// @return The approved address for this NFT, or the zero address if there is none
    function getApproved(uint256 _tokenId) external view returns (address);

    /// @notice Query if an address is an authorized operator for another address
    /// @param _owner The address that owns the NFTs
    /// @param _operator The address that acts on behalf of the owner
    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);
}

interface ERC165 {
    /// @notice Query if a contract implements an interface
    /// @param interfaceID The interface identifier, as specified in ERC-165
    /// @dev Interface identification is specified in ERC-165. This function
    ///  uses less than 30,000 gas.
    /// @return `true` if the contract implements `interfaceID` and
    ///  `interfaceID` is not 0xffffffff, `false` otherwise
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}

interface ERC721TokenReceiver {
    /// @notice Handle the receipt of an NFT
    /// @dev The ERC721 smart contract calls this function on the
    /// recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return
    /// of other than the magic value MUST result in the transaction being reverted.
    /// @notice The contract address is always the message sender.
    /// @param _operator The address which called `safeTransferFrom` function
    /// @param _from The address which previously owned the token
    /// @param _tokenId The NFT identifier which is being transferred
    /// @param _data Additional data with no specified format
    /// @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`
    /// unless throwing
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);
 }
